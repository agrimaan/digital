const axios = require('axios');

// Service URLs with fallbacks
const USER_SVC = process.env.USER_SERVICE_URL || 'http://localhost:3002';
const FIELD_SVC = process.env.FIELD_SERVICE_URL || 'http://localhost:3003';
const CROP_SVC = process.env.CROP_SERVICE_URL || 'http://localhost:3005';
const MARKETPLACE_SVC = process.env.MARKETPLACE_SERVICE_URL || 'http://localhost:3006';
const IOT_SVC = process.env.IOT_SERVICE_URL || 'http://localhost:3004';
const ANALYTICS_SVC = process.env.ANALYTICS_SERVICE_URL || 'http://localhost:3009';
const BLOCKCHAIN_SVC = process.env.BLOCKCHAIN_SERVICE_URL || 'http://localhost:3011';

// Helper function for HTTP requests
const httpRequest = async (serviceUrl, endpoint, method = 'GET', data = null, headers = {}) => {
  try {
    const config = {
      method,
      url: `${serviceUrl}${endpoint}`,
      headers: {
        'Content-Type': 'application/json',
        ...headers
      },
      timeout: 8000
    };

    if (data && (method === 'POST' || method === 'PUT' || method === 'PATCH')) {
      config.data = data;
    }

    const response = await axios(config);
    return response.data;
  } catch (error) {
    console.error(`HTTP request failed: ${method} ${serviceUrl}${endpoint}`, error.message);
    throw new Error(`Service request failed: ${error.message}`);
  }
};

// Helper to get aggregated data from multiple services
const getAggregatedData = async (requests) => {
  try {
    const results = await Promise.allSettled(requests);
    
    return results.map((result, index) => {
      if (result.status === 'fulfilled') {
        return result.value;
      } else {
        console.error(`Request ${index} failed:`, result.reason);
        return { error: result.reason.message, data: null };
      }
    });
  } catch (error) {
    console.error('Aggregation error:', error);
    throw new Error(`Data aggregation failed: ${error.message}`);
  }
};

/**
 * Get default dashboard for an admin
 * @param {string} adminId - Admin ID
 * @returns {Object} Dashboard data from multiple services
 */
exports.getDefaultDashboard = async (adminId) => {
  try {
    // Parallel requests to all services for dashboard data
    const [
      userStats,
      fieldStats,
      cropStats,
      orderStats,
      sensorStats,
      systemHealth,
      blockchainStats
    ] = await getAggregatedData([
      httpRequest(USER_SVC, '/api/analytics/users'),
      httpRequest(FIELD_SVC, '/api/analytics/fields'),
      httpRequest(CROP_SVC, '/api/analytics/crops'),
      httpRequest(MARKETPLACE_SVC, '/api/analytics/orders'),
      httpRequest(IOT_SVC, '/api/analytics/devices'),
      httpRequest(ANALYTICS_SVC, '/api/analytics/health'),
      httpRequest(BLOCKCHAIN_SVC, '/api/blockchain/market')
    ]);

    // Extract counts from blockchain data
    const blockchainData = blockchainStats?.data?.data || blockchainStats?.data || {};
    const landTokenCount = blockchainData?.totalTokens || 0;

    // Construct dashboard from service data
    const dashboard = {
      id: `admin-dashboard-${adminId}`,
      adminId: adminId,
      name: 'Admin Dashboard',
      type: 'default',
      widgets: [
        {
          id: 'user-stats',
          type: 'stats',
          title: 'User Statistics',
          data: userStats.data || { totalUsers: 0, newUsers: 0, activeUsers: 0 }
        },
        {
          id: 'field-stats',
          type: 'stats',
          title: 'Field Statistics',
          data: fieldStats.data || { totalFields: 0, activeFields: 0, totalArea: 0 }
        },
        {
          id: 'crop-stats',
          type: 'stats',
          title: 'Crop Statistics',
          data: cropStats.data || { totalCrops: 0, activeCrops: 0, cropTypes: {} }
        },
        {
          id: 'order-stats',
          type: 'stats',
          title: 'Order Statistics',
          data: orderStats.data || { totalOrders: 0, pendingOrders: 0, completedOrders: 0 }
        },
        {
          id: 'sensor-stats',
          type: 'stats',
          title: 'Sensor Statistics',
          data: sensorStats.data || { totalSensors: 0, activeSensors: 0, alertCount: 0 }
        },
        {
          id: 'blockchain-stats',
          type: 'stats',
          title: 'Blockchain Statistics',
          data: {
            totalTokens: landTokenCount,
            totalTransactions: blockchainData?.totalTransactions || 0,
            activeContracts: blockchainData?.activeContracts || 0
          }
        },
        {
          id: 'system-health',
          type: 'health',
          title: 'System Health',
          data: systemHealth.data || { status: 'unknown', services: [] }
        }
      ],
      layout: 'default',
      createdAt: new Date(),
      updatedAt: new Date()
    };

    return dashboard;
  } catch (error) {
    console.error('Get default dashboard error:', error);
    // Return fallback dashboard with empty data
    return {
      id: `admin-dashboard-${adminId}`,
      adminId: adminId,
      name: 'Admin Dashboard',
      type: 'default',
      widgets: [
        {
          id: 'error-widget',
          type: 'error',
          title: 'Service Unavailable',
          data: { message: 'Some services are currently unavailable' }
        }
      ],
      layout: 'default',
      createdAt: new Date(),
      updatedAt: new Date()
    };
  }
};

/**
 * Get dashboard by ID (admin view)
 * @param {string} id - Dashboard ID
 * @param {string} adminId - Admin ID
 * @returns {Object} Dashboard data
 */
exports.getDashboardById = async (id, adminId) => {
  try {
    // Get real-time data from services instead of stored dashboard
    const dashboard = await exports.getDefaultDashboard(adminId);
    
    // Add specific dashboard ID
    dashboard.id = id;
    
    return dashboard;
  } catch (error) {
    console.error('Get dashboard error:', error);
    throw new Error(`Failed to get dashboard: ${error.message}`);
  }
};

/**
 * Get all dashboards for an admin
 * @param {string} adminId - Admin ID
 * @returns {Array} List of dashboards
 */
exports.getAllDashboards = async (adminId) => {
  try {
    // For now, return just the default dashboard
    // In future, this could support multiple custom dashboards
    const defaultDashboard = await exports.getDefaultDashboard(adminId);
    
    return [defaultDashboard];
  } catch (error) {
    console.error('Get all dashboards error:', error);
    throw new Error(`Failed to get dashboards: ${error.message}`);
  }
};

/**
 * Create a new dashboard
 * @param {Object} dashboardData - Dashboard data
 * @param {Object} adminData - Admin data for audit logging
 * @returns {Object} Created dashboard
 */
exports.createDashboard = async (dashboardData, adminData) => {
  try {
    // Create dashboard by aggregating real-time data
    const dashboard = await exports.getDefaultDashboard(adminData.id);
    
    // Apply any custom configurations from dashboardData
    if (dashboardData.name) {
      dashboard.name = dashboardData.name;
    }
    if (dashboardData.layout) {
      dashboard.layout = dashboardData.layout;
    }
    if (dashboardData.widgets) {
      dashboard.widgets = [...dashboard.widgets, ...dashboardData.widgets];
    }

    // Log the action via audit service
    try {
      await httpRequest(
        process.env.USER_SERVICE_URL || 'http://localhost:3002',
        '/api/admin/audit-logs',
        'POST',
        {
          adminId: adminData.id,
          adminName: adminData.name,
          action: 'create',
          resourceType: 'dashboard',
          resourceId: dashboard.id,
          description: `Created new dashboard: ${dashboard.name}`,
          status: 'success',
          ipAddress: adminData.ipAddress,
          userAgent: adminData.userAgent
        },
        { Authorization: `Bearer ${adminData.token}` }
      );
    } catch (auditError) {
      console.error('Audit log creation failed:', auditError);
      // Continue without audit log if service is unavailable
    }

    return dashboard;
  } catch (error) {
    console.error('Create dashboard error:', error);
    throw new Error(`Failed to create dashboard: ${error.message}`);
  }
};

/**
 * Update a dashboard
 * @param {string} id - Dashboard ID
 * @param {Object} updateData - Data to update
 * @param {Object} adminData - Admin data for audit logging
 * @returns {Object} Updated dashboard
 */
exports.updateDashboard = async (id, updateData, adminData) => {
  try {
    // Get current dashboard data
    const currentDashboard = await exports.getDashboardById(id, adminData.id);
    
    // Merge updates with current data
    const updatedDashboard = {
      ...currentDashboard,
      ...updateData,
      id: id, // Preserve ID
      adminId: adminData.id, // Preserve ownership
      updatedAt: new Date()
    };

    // Log the action via audit service
    try {
      await httpRequest(
        process.env.USER_SERVICE_URL || 'http://localhost:3002',
        '/api/admin/audit-logs',
        'POST',
        {
          adminId: adminData.id,
          adminName: adminData.name,
          action: 'update',
          resourceType: 'dashboard',
          resourceId: id,
          description: `Updated dashboard: ${updatedDashboard.name}`,
          status: 'success',
          ipAddress: adminData.ipAddress,
          userAgent: adminData.userAgent
        },
        { Authorization: `Bearer ${adminData.token}` }
      );
    } catch (auditError) {
      console.error('Audit log creation failed:', auditError);
      // Continue without audit log if service is unavailable
    }

    return updatedDashboard;
  } catch (error) {
    console.error('Update dashboard error:', error);
    throw new Error(`Failed to update dashboard: ${error.message}`);
  }
};

/**
 * Delete a dashboard
 * @param {string} id - Dashboard ID
 * @param {Object} adminData - Admin data for audit logging
 * @returns {Object} Deletion result
 */
exports.deleteDashboard = async (id, adminData) => {
  try {
    // For now, just log the deletion (since we're not persisting dashboards)
    // In future, this would delete from database
    
    // Log the action via audit service
    try {
      await httpRequest(
        process.env.USER_SERVICE_URL || 'http://localhost:3002',
        '/api/admin/audit-logs',
        'POST',
        {
          adminId: adminData.id,
          adminName: adminData.name,
          action: 'delete',
          resourceType: 'dashboard',
          resourceId: id,
          description: `Deleted dashboard: ${id}`,
          status: 'success',
          ipAddress: adminData.ipAddress,
          userAgent: adminData.userAgent
        },
        { Authorization: `Bearer ${adminData.token}` }
      );
    } catch (auditError) {
      console.error('Audit log creation failed:', auditError);
      // Continue without audit log if service is unavailable
    }

    return { success: true, message: 'Dashboard deleted successfully' };
  } catch (error) {
    console.error('Delete dashboard error:', error);
    throw new Error(`Failed to delete dashboard: ${error.message}`);
  }
};

/**
 * Get dashboard widgets data
 * @param {string} dashboardId - Dashboard ID
 * @param {Object} adminData - Admin data
 * @returns {Object} Widget data
 */
exports.getDashboardWidgets = async (dashboardId, adminData) => {
  try {
    // Get fresh data from all services for dashboard widgets
    const dashboard = await exports.getDashboardById(dashboardId, adminData.id);
    
    // Refresh widget data with latest information
    const refreshedWidgets = await Promise.all(
      dashboard.widgets.map(async (widget) => {
        try {
          // Refresh data based on widget type
          switch (widget.type) {
            case 'stats':
              return await refreshStatsWidget(widget, adminData);
            case 'chart':
              return await refreshChartWidget(widget, adminData);
            case 'table':
              return await refreshTableWidget(widget, adminData);
            case 'health':
              return await refreshHealthWidget(widget, adminData);
            default:
              return widget;
          }
        } catch (refreshError) {
          console.error(`Error refreshing widget ${widget.id}:`, refreshError);
          return {
            ...widget,
            data: { error: 'Failed to refresh data', originalData: widget.data }
          };
        }
      })
    );

    return {
      ...dashboard,
      widgets: refreshedWidgets,
      lastRefreshed: new Date()
    };
  } catch (error) {
    console.error('Get dashboard widgets error:', error);
    throw new Error(`Failed to get dashboard widgets: ${error.message}`);
  }
};

// Helper functions to refresh different widget types

async function refreshStatsWidget(widget, adminData) {
  // Get fresh statistics based on widget ID
  let freshData = {};
  
  switch (widget.id) {
    case 'user-stats':
      freshData = await httpRequest(USER_SVC, '/api/analytics/users');
      break;
    case 'field-stats':
      freshData = await httpRequest(FIELD_SVC, '/api/analytics/fields');
      break;
    case 'crop-stats':
      freshData = await httpRequest(CROP_SVC, '/api/analytics/crops');
      break;
    case 'order-stats':
      freshData = await httpRequest(MARKETPLACE_SVC, '/api/analytics/orders');
      break;
    case 'sensor-stats':
      freshData = await httpRequest(IOT_SVC, '/api/analytics/devices');
      break;
    case 'blockchain-stats':
      const blockchainData = await httpRequest(BLOCKCHAIN_SVC, '/api/blockchain/market');
      const data = blockchainData?.data?.data || blockchainData?.data || {};
      freshData = {
        totalTokens: data?.totalTokens || 0,
        totalTransactions: data?.totalTransactions || 0,
        activeContracts: data?.activeContracts || 0
      };
      break;
    default:
      freshData = widget.data; // Keep existing data if no refresh logic
  }
  
  return {
    ...widget,
    data: freshData.data || freshData
  };
}

async function refreshChartWidget(widget, adminData) {
  // Implement chart data refresh logic
  // This would depend on the specific chart type and data source
  return {
    ...widget,
    data: widget.data, // Keep existing for now
    lastRefreshed: new Date()
  };
}

async function refreshTableWidget(widget, adminData) {
  // Implement table data refresh logic
  // This would depend on the specific table and data source
  return {
    ...widget,
    data: widget.data, // Keep existing for now
    lastRefreshed: new Date()
  };
}

async function refreshHealthWidget(widget, adminData) {
  // Refresh system health data
  const healthData = await httpRequest(ANALYTICS_SVC, '/api/analytics/health');
  
  return {
    ...widget,
    data: healthData.data || healthData
  };
}